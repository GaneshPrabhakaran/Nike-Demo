# require_relative '../../../vendor/jars/db2driver-9.5.jar'
# require_relative '../../../vendor/jars/ojdbc14.jar'

require 'benchmark'

module Database
  class Connection
    #
    # Private constructor.
    #
    def initialize(db_url, config, type)
      @db_url = db_url
      @config = config
      @type = type
      @connection = nil
    end
    private_class_method :new

    #
    # Creates a Database instance for querying a DB2 database.
    # @param [Database::Configuration] config Database connection configuration.
    # @return [Database] Database instance.
    #
    def self.db2(config)
      db_url = "//#{config['host']}:#{config['port']}/#{config['db_name']}"
      # In RE environments, the schema actually changes between sitedb and bops, but on the google cloud environments, the schema is always DB2MCYS
      if (config['schema'] == "DB2MBOP" || config['schema'] == "DB2BBOP" || config['db_type'] == 'bops')
        new(db_url, config, "bops")
      else
        new(db_url, config, "db2")
      end

    end

    #
    # Creates a Database instance for querying an Oracle database.
    # @param [Database::Configuration] config Database connection configuration.
    # @return [Database] Database instance.
    #
    def self.oracle(config)
      db_url = "//#{config['host']}:#{config['port']}:#{config['db_name']}"
      new(db_url, config, "oracle")
    end

    #
    # Connects to the database.
    # @return [java.sql.Connection] Database connection.
    #
    def connect
      if (@type == "db2")
        @config
        Models::Databases::SiteDatabase::Base.setup_connection(@config)
      elsif (@type == "bops")
        @config
        Models::Databases::Bops::Base.setup_connection(@config)
      else
        Models::Databases::Dyces::Base.setup_connection(@config)
      end

     @connection = @type

      Log.instance.debug "Connected to #@db_url"
      self
    end

    #
    # Executes a SQL statement against the database.
    #
    # @example Fetch product names from the database for a set of product IDs.
    #   connection = Database::Connection.db2('11.1.2.3', '60000', 'MLQ10', 'username', 'password').connect()
    #   result_set = connection.execute("SELECT * FROM product WHERE prod_id IN (77589, 621467, 494420)")
    #   while (result_set.next()) do
    #     puts "Found product: #{result_set.getString('prod_name')}"
    #   end
    #   connection.close()
    #
    # @return [java.sql.ResultSet] The result set generated by the query.
    #                              See: http://docs.oracle.com/javase/7/docs/api/java/sql/ResultSet.html
    #
    def execute(query)
      @connection.nil? and raise "Attempting to query a connection that isn't open."

      result_set = nil
      benchmark = nil

      #benchmark = Benchmark.measure { result_set = statement.executeQuery(query) }
      if (@type == "db2")
        benchmark = Benchmark.measure { result_set = Models::Databases::SiteDatabase::Base.connection.select_all(query) }
      elsif (@type == "bops")
        benchmark = Benchmark.measure { result_set = Models::Databases::Bops::Base.connection.select_all(query) }
      else
        benchmark = Benchmark.measure { result_set = Models::Databases::Dyces::Base.connection.select_all(query) }
      end
      result_set = ResultSet.new(result_set) #wrap the result set so we get the old jdbc behavior
      Log.instance.debug "Query took #{sprintf('%.2f', benchmark.real)} seconds: '#{query[0..80].gsub(/\s/, ' ')}...'"

      result_set
    end

    #
    # Executes an update SQL statement against the database.
    #
    def execute_insert(query)
      @connection.nil? and raise "Attempting to query a connection that isn't open."

      if (@type == "db2")
        Models::Databases::SiteDatabase::Base.connection.execute(query)
      elsif (@type == "bops")
        Models::Databases::Bops::Base.connection.execute(query)
      else
        Models::Databases::Dyces::Base.connection.execute(query)
      end

    end

    #
    # Closes the current connection.
    #
    def close
      #active record should do our connections for us so just set to nil
      @connection = nil
      # Remove this connection from the list of open connections.
      #@@open_connection = @@open_connections.reject { |c| c[:db_url] == @db_url }
      Log.instance.debug "Disconnected from #@db_url"
    end

    #
    # Closes all open connections.
    #
    def self.close_all
      #nothing to do here active record is managing the db connections
      @connection = nil
    end

    #
    #Check for connection close
    #
    def closed?
      @connection.nil?
    end
  end
end